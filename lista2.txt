'''
- Lista de Exercícios II -
- Trabalho individual

Usando NumPy, MatPlotLib e SciPy implemente os seguintes exercícios para exploração
e fixação de comandos e métodos destes módulos.

Os gráficos plotados ou cópias de tela de execução destes exercícios estão
disponíveis na pasta "Exemplos de Resultados" e servem para exemplificar
uma possível solução (estão lá apenas para servir de apoio de explicação).


1) Utilizando o  intervalo [-PI, +PI], plote um gráfico usando o cos(x) como abscissa e o sen(x) como ordenada.
   Pesquise a função sobre axes no matplotlib (ou como foi feito nos exemplos anteriores)
   para deixar o gráfico quadrado, mesma proporção largura x altura,
   caso contrário o círculo parecerá uma elipse.


2) Empregando sen(x) no mesmo intervalo [-PI, +PI], mas agora usando np.arange (com passo 0.2),
   plote 6 gráficos, de sen(x) até sen(x-1), deslocando cada plot de 0.2,
   ou seja sen(x), sen(x-0.2) etc., usando para chamada ao plot os seguintes modelos de linhas:
   '-'    '--'    ':'     '-.'      '.'      'o'
   Depois, brinque com o parâmetro opcional color='cor' testando cores disponíveis (ver na documentação)


3) Plote os dois polinômios f(x) e g(x):
   f(x) = -2xˆ4 + 3xˆ3 + 7xˆ2 -10x + 18
   g(x) = xˆ4 +2xˆ3  -13xˆ2 -14x + 24
   Com x no intervalo [-4.5, 4.5] com 300 pontos. Antes de plt.show(), chame plt.grid().
   Implemente as funções em código Python:
   def f(x):
      # retorno da função f
   def g(x):
      # retorno da função g
   Coloque as equações dos polinômios como rótulos (ver nos exemplos anteriores).
   Pesquise como centralizar os spines em 0,0 de forma a criar um gráfico com
   os eixos cartesianos mostrados no formato tradicional.


4) Crie uma função python que retorna o maior de dois números enviados por parâmetro.
   Ela irá funcionar de maneira regular, ou seja, operando sobre 2 escalares.
   Verifique o funcionamento da função NumPy vectorize, e crie então a função
   que opera sobre vetores.

   Teste sua função duas vezes:
   a) com dois arrays numpy de 10 posições sorteadas de números inteiros
   no intervalo [10, 100[
   b) com dois arrays numpy de 10 posições sorteadas de números reais
   no intervalo ]0, 1[ .
   Em ambos cenários mostre os 3 vetores e use funções do NumPy para o sorteio.


5) Calculando área aproximada com Soma de Riemann

   Elabore um programa que aplique a Soma de Riemann para estimar a área
   solicitando ao usuário o tamanho do passo (base do retângulo), apresente
   o valor estimado da área e o erro relativo.
   Os passos devem ser frações exatas de 1, como por exemplo:
   1, 0.5, 0.25, 0.125, 0.1, 0.0625, 0.05, 0.04, 0.03125, 0.025, 0.0125 etc
   para não extrapolarem o intervalo.

   Erro relativo = | analitico - aproximado | / | analítico |

   Plote o gráfico apresentando os retângulos, o valor aproximado e o erro
   relativo.
   Dica para plotar os retângulos: simplesmente usar plt.bar (deixando as cores sem interferir)
   https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.bar.html

   Para comparar o resultados, crie 3 gráficos (sub plots) na mesma plotagem
   e contabilize os três valores da área calculada:
   - pegando altura pela esquerda (antes do passo)
   - pegando altura no meio (métade do passo)
   - pegando altura pela direita (depois do passo)

   Use a função python criada para calcular as seguintes integrais definidas:
   a) Para a reta f(x) = 2x, integrada no intervalo [1, 4], cuja solução analítica é 15.
   (ver gráficos exemplos de resultado)

   b) Para a função f(x) = 1/8(x^2 -2x + 8), integrada no intervalo [-2, 4], cuja solução
   analítica é 15/6.
'''


#    ************************************* EXERCÍCIO 1 ************************************* 

# BIBLIOTECAS
import numpy as np
import matplotlib.pyplot as plt

# VARIÁVEIS
num = np.linspace(-np.pi, np.pi, 100)
x = np.cos(num)
y = np.sin(num)

# PLOTS:
plt.figure(figsize=(3,4))
plt.plot(x,y)
plt.axis('scaled')
plt.suptitle('EXERCICIO 1')
plt.show()

#    ************************************* EXERCÍCIO 2 ************************************* 

# bibliotecas
import matplotlib.pyplot as plt
import numpy as np

# variáveis globais
x = np.arange(-np.pi, np.pi,0.2)
l_pontos = []

#formatos = ['-', '--', ':','-.', '.', 'o']             # não funciona o comando passado pelo professor
formatos = ['-', '--', ':','-.', '--', ':']
cores = ['b', 'g', 'r', 'c', 'm', 'y']

for i in range(6):                                      # loop para realizar iterações
    plt.grid()                                          # grid inicial para todos os gráficos

    l_pontos.append(np.sin(x-0.2*i))                    # comandos principais
    plt.subplot(3,2,i+1)
    plt.plot(x, l_pontos[i], linestyle = formatos[i], color = cores[i])

    plt.title(f"Gráfico sen(x-{round(0.2*i, 2)})")      # printa o titulo com arredondamento para duas casas decimais do valor de 0.2*i
    plt.xlabel('Eixo x')
    plt.ylabel('Eixo Y')

plt.grid()                                              # grid no ultimo gráfico
plt.suptitle('EXERCICIO 2')
plt.show()


#    ************************************* EXERCÍCIO 3 ************************************* 

# BIBLIOTECAS
import matplotlib.pyplot as plt
import numpy as np


# FUNÇÕES AUXILIARES
def f(x):
    return -(2*(x**4)) + (3*(x**3)) + (7*(x**2)) - (10*x) + 18

def g(x):
    return (x**4) + (2*(x**3)) - (13*(x**2)) - (14*x) + 24


# VARIÁVEIS
eixoX = np.linspace(-4.5,4.5,300)
f1 = np.vectorize(f)
f2 = np.vectorize(g)
eixoY1 = f1(eixoX)
eixoY2= f2(eixoX)

# PLOTAGEM GRÁFICA
fig, ax = plt.subplots()
# making the top and right spine invisible:
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')

# moving bottom spine up to y=0 position:
ax.xaxis.set_ticks_position('bottom')
ax.spines['bottom'].set_position(('axes',0))

# moving left spine to the right to position x == 0:
ax.yaxis.set_ticks_position('left')
ax.spines['left'].set_position(('axes',0))


plt.plot(eixoX, eixoY1, label = 'Gráfico f(x)')                 # plotagem gráfica das funções
plt.plot(eixoX, eixoY2, label = 'Gráfico g(x)')

plt.title('EXERCICIO 3')                                        # layout do gráfico 
plt.xlabel('Eixo X')
plt.ylabel('Eixo Y')
plt.legend()
plt.grid()

plt.show()


#    ************************************* EXERCÍCIO 4 ************************************* 

# BIBLIOTECAS
import numpy as np
import random


# FUNÇÕES AUXILIARES
def myfunc(a, b):                  # funcao que retorna valor maior
    if a>=b: return a
    else: return b


# EXERCICIO A:
a = 10*[0]                         # gera lista com 10 elementos
b = 10*[0]
for i in range(10):                # laço for para gerar lista com 10 elementos inteiros 
    a[i] = random.randrange(10,99)
    b[i] = random.randrange(10,99)   
array_a = np.array(a)              # transforma lista na classe array
array_b = np.array(b)
vfunc = np.vectorize(myfunc)       # vetorização do array para operar sobre ele
valor = vfunc(array_a,array_b)     # maior entre vetores

#print(array_a)
#print(array_b)
#print(valor)                       # valor final


# EXERCÍCIO B:
aa = 10*[0]                         # gera lista com 10 elementos
bb = 10*[0]
for i in range(10):                # laço for para gerar lista com 10 elementos inteiros 
    aa[i] = random.random()
    bb[i] = random.random()   
array_aa = np.array(aa)              # transforma lista na classe array
array_bb = np.array(bb)
vfunc_2 = np.vectorize(myfunc)       # vetorização do array para operar sobre ele
valor_2 = vfunc_2(array_aa,array_bb) # maior entre vetores

#print(array_aa)
#print(array_bb)
#print('ARRAY RESULTADO\n',valor_2)                       # valor final


#    ************************************* EXERCÍCIO 5 ************************************* 

# BIBLIOTECAS
import numpy as np
import matplotlib.pyplot as plt

# ENTRADA DAS VARIÁVEIS
passo = float(input('Entre com o valor do passo:\t'))

# ------------------------------------------  exercicio A ------------------------------------
'''
inicio = 1
fim = 5
solucao = 15

x = np.arange(inicio, fim, passo)
z = [-passo/2, 0, passo/2]


xx = len(x) * [0]                  # gera lista com valores de x
for i in range(len(x)):
    xx[i] = x[i] + (passo/2)   

for k in range(len(z)):            # lista com valores de y
    y = len(x) * [0]
    for i in range(len(x)):
        y[i] = 2 * (xx[i] + z[k]) 
    
    area = len(x) * [0]            # calculo da area
    for i in range(len(x)-1):
        area[i+1] = (xx[i+1] - xx[i]) * (y[i]) + area[i]

    erro = len(x)*[0]              # calculo do erro
    erro[k] = abs(((area[len(x)-1]-solucao)/solucao)*100)
       
    print('xx\t', xx)
    print('y\t', y)        
    print('area\t', area)
    print('erro\t', erro[k], '%')
    
    print()

fig, axs = plt.subplots(3,1,sharex= True, figsize = (8,20))       # plotagem das figuras
plt.suptitle('Exercício 5')                      # título
plt.subplots_adjust(wspace = 0.25, hspace=0.5)                    # ajuste de espaço entre gráficos


axs[0].plot(x, y, 'r', marker = 'o', label = 'f(x)')
axs[0].bar(x+z[0],y, width = passo)
axs[0].set_xlabel('eixo x')                                           # configuração dos eixos
axs[0].set_ylabel('eixo y')
axs[0].set_title(f'Erro relativo:  {erro[0]}%')                          # subtítulo
#axs[0].set_xlim((x[0]),(x[len(x)-1]*1.25))                            # limite do eixo x
axs[0].legend()
axs[0].grid()

axs[1].plot(x, y, 'b', marker = '*', label = 'f(x)')     # plotagem gráfico 2: função de Euler
axs[1].bar(x+z[1],y, width = passo)
axs[1].set_xlabel('eixo x')                                           # configuração dos eixos
axs[1].set_ylabel('eixo y')
axs[1].set_title(f'Erro relativo:  {erro[1]}%')                                  # subtítulo
axs[1].legend()
axs[1].grid()

axs[2].plot(x, y, 'k', marker = '+', label = 'f(x)')     # plotagem gráfico 3: comportamento na origem
axs[2].bar(x+z[2],y, width = passo)
axs[2].set_xlabel('eixo x')                                          # configuração dos eixos
axs[2].set_ylabel('eixo y')
axs[2].set_title(f'Erro relativo:  {erro[2]}%')                           # subtítulo
#axs[2].set_ylim(-5, 5)                                                # limite do eixo y
axs[2].legend()
axs[2].grid()

plt.show()
'''


# ------------------------------------------  exercicio B ------------------------------------
#b) Para a função f(x) = 1/8(x^2 -2x + 8), integrada no intervalo [-2, 4], cuja solução analítica é 15/6.

def plotagem(x, y, z, passo):    

    fig, axs = plt.subplots(3,1,sharex= True, figsize = (8,20))       # plotagem das figuras
    plt.suptitle('Exercício 5 - Questão B')                           # título
    plt.subplots_adjust(wspace = 0.25, hspace=0.5)                    # ajuste de espaço entre gráficos

    cores = ['r', 'b', 'k']
    marcadores = ['o', '*', '+']
    
    for k in range(len(z)):
        axs[k].plot(x, y[k], cores[k], marker = marcadores[k], label = 'f(x)')
        axs[k].bar(x+z[k],y[k], width = passo)
        axs[k].set_xlabel('eixo x')                                           # configuração dos eixos
        axs[k].set_ylabel('eixo y')
        axs[k].set_title(f'Erro relativo ao passo {z[k]}:  {erro[0]}%')                          # subtítulo
        #axs[k].set_xlim((x[0]),(x[len(x)-1]*1.25))                            # limite do eixo x
        axs[k].legend()
        axs[k].grid()
        
    plt.show()

inicio = -2
fim = 4
solucao = 15/6

x = np.arange(inicio, fim, passo)
z = [-passo/2, 0, passo/2]

xx = len(x) * [0]                  
yy = len(xx)*[0]
y = [yy, yy, yy]                   
a = len(xx) * [0]
area = [a, a, a]
erro = len(z) * [0]


for k in range(len(z)):
    for i in range(len(x)):
        xx[i] = x[i] + (passo/2)                                       # calculo de x
        y[k][i] = 1/(8*(((xx[i]+z[k])**2)-2*((xx[i]+z[k])+8)))         # valores de y
    for i in range(len(xx)-1):                               
        area[k][i+1] = area[k][i] + ((xx[i+1] - xx[i]) * y[k][i+1])    # valores da area
    erro[k] = abs((area[k][len(xx)-1] - solucao)/ solucao)             # calculo do erro em relacao ao passo
    print(f'Area com passo de {z[k]}\t\t{abs(area[k][len(xx)-1])}')
    print(f'Erro com passo de {z[k]}\t\t{erro[k]}')
    print()

    
plotagem(x, y, z, passo)    
